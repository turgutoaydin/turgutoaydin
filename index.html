<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pool Spin</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(180deg, #0f0c29, #302b63, #24243e);
      color: white;
      height: 100vh;
      overflow: hidden;
      touch-action: manipulation;
    }
    #game {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 10px;
    }
    header {
      text-align: center;
      padding: 10px 0;
      background: rgba(0,0,0,0.3);
      border-radius: 2px solid #ffeb3b;
      border-radius: 15px;
      margin-bottom: 10px;
    }
    h1 {
      font-size: 28px;
      color: #ffeb3b;
      text-shadow: 0 0 10px #ffeb3b;
    }
    .score {
      font-size: 20px;
      margin-top: 5px;
    }
    #board {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      border-radius: 15px;
      max-width: 400px;
      margin: 0 auto;
      box-shadow: 0 0 20px rgba(255,235,59,0.5);
    }
    .tile {
      aspect-ratio: 1;
      border-radius: 12px;
      background-size: 80%;
      background-position: center;
      background-repeat: no-repeat;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
      animation: drop 0.6s ease-out;
    }
    .selected { transform: scale(1.15); box-shadow: 0 0 20px #fff; z-index: 10; }
    .match { animation: pop 0.4s ease-out forwards; }
    
    /* Renkli havuz topları teması */
    .red    { background: radial-gradient(circle at 30% 30%, #ff5e62, #ff1744); }
    .blue   { background: radial-gradient(circle at 30% 30%, #6eb5ff, #2979ff); }
    .green  { background: radial-gradient(circle at 30% 30%, #80e27e, #00c853); }
    .yellow { background: radial-gradient(circle at 30% 30%, #ffff6b, #ffd600); }
    .purple { background: radial-gradient(circle at 30% 30%, #e040fb, #9c27b0); }
    .orange { background: radial-gradient(circle at 30% 30%, #ff9e80, #ff5722); }

    footer {
      text-align: center;
      padding: 15px;
    }
    #spinBtn {
      padding: 15px 40px;
      font-size: 22px;
      font-weight: bold;
      background: linear-gradient(#ffeb3b, #ffb300);
      color: #000;
      border: none;
      border-radius: 50px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    }
    #spinBtn:disabled { opacity: 0.6; }

    @keyframes drop {
      from { transform: translateY(-1000px); opacity: 0; }
      to   { transform: translateY(0); opacity: 1; }
    }
    @keyframes pop {
      0%   { transform: scale(1); }
      50%  { transform: scale(1.3); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="game">
    <header>
      <h1>Pool Spin</h1>
      <div class="score">Skor: <span id="score">0</span></div>
    </header>

    <div id="board"></div>

    <footer>
      <button id="spinBtn">SPIN!</button>
    </footer>
  </div>

  <script>
    // Telegram WebApp hazır olduğunda büyüt butonu vs.
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();

    const ROWS = 5;
    const COLS = 6;
    const TYPES = ['red', 'blue', 'green', 'yellow', 'purple', 'orange'];
    let board = [];
    let score = 0;
    let isSpinning = false;
    let selectedTile = null;

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const spinBtn = document.getElementById('spinBtn');

    function createBoard() {
      boardEl.innerHTML = '';
      board = [];
      for (let r = 0; r < ROWS; r++) {
        board[r] = [];
        for (let c = 0; c < COLS; c++) {
          const tile = document.createElement('div');
          tile.classList.add('tile');
          const type = TYPES[Math.floor(Math.random() * TYPES.length)];
          tile.classList.add(type);
          tile.dataset.row = r;
          tile.dataset.col = c;
          tile.addEventListener('click', () => selectTile(tile));
          boardEl.appendChild(tile);
          board[r][c] = { element: tile, type };
        }
      }
      checkMatches();
    }

    function selectTile(tile) {
      if (isSpinning) return;
      if (selectedTile === tile) {
        tile.classList.remove('selected');
        selectedTile = null;
        return;
      }
      if (selectedTile) selectedTile.classList.remove('selected');
      selectedTile = tile;
      tile.classList.add('selected');
    }

    function swapTiles(tile1, tile2) {
      const r1 = +tile1.dataset.row, c1 = +tile1.dataset.col;
      const r2 = +tile2.dataset.row, c2 = +tile2.dataset.col;

      // Sadece yatay/dikey komşuysa izin ver
      if ((Math.abs(r1 - r2) === 1 && c1 === c2) || (Math.abs(c1 - c2) === 1 && r1 === r2)) {
        // Swap
        const temp = board[r1][c1];
        board[r1][c1] = board[r2][c2];
        board[r2][c2] = temp;

        board[r1][c1].element.dataset.row = r1; board[r1][c1].element.dataset.col = c1;
        board[r2][c2].element.dataset.row = r2; board[r2][c2].element.dataset.col = c2;

        // Görsel swap
        const tempType = tile1.className;
        tile1.className = tile2.className;
        tile2.className = tempType;

        selectedTile.classList.remove('selected');
        selectedTile = null;

        setTimeout(() => {
          if (checkMatches()) {
            dropTiles();
          } else {
            // Geri al (eşleşme yoksa)
            // basitçe tekrar swap
            swapTiles(tile1, tile2);
          }
        }, 300);
      }
    }

    function checkMatches() {
      let found = false;
      const toRemove = new Set();

      // Yatay
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS - 2; c++) {
          const type = board[r][c].type;
          if (type && type === board[r][c+1].type && type === board[r][c+2].type) {
            toRemove.add(board[r][c].element);
            toRemove.add(board[r][c+1].element);
            toRemove.add(board[r][c+2].element);
            found = true;
          }
        }
      }

      // Dikey
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS - 2; r++) {
          const type = board[r][c].type;
          if (type && type === board[r+1][c].type && type === board[r+2][c].type) {
            toRemove.add(board[r][c].element);
            toRemove.add(board[r+1][c].element);
            toRemove.add(board[r+2][c].element);
            found = true;
          }
        }
      }

      if (found) {
        score += toRemove.size * 10;
        scoreEl.textContent = score;
        toRemove.forEach(el => {
          el.classList.add('match');
          const r = +el.dataset.row, c = +el.dataset.col;
          board[r][c].type = null;
        });
      }
      return found;
    }

    function dropTiles() {
      let dropped = false;
      for (let c = 0; c < COLS; c++) {
        let empty = [];
        for (let r = ROWS - 1; r >= 0; r--) {
          if (!board[r][c].type) empty.push(r);
          else if (empty.length > 0) {
            const targetR = empty.shift();
            // Swap
            board[targetR][c] = board[r][c];
            board[r][c] = { element: board[targetR][c].element, type: null };
            board[targetR][c].element.dataset.row = targetR;
            board[targetR][c].element.style.animation = 'drop 0.6s ease-out';
            dropped = true;
            empty.push(r);
          }
        }
        // Üstteki boşluklara yeni taşlar
        empty.forEach(r => {
          const tile = board[r][c].element;
          const type = TYPES[Math.floor(Math.random() * TYPES.length)];
          tile.className = 'tile ' + type;
          tile.style.animation = 'drop 0.6s ease-out';
          board[r][c].type = type;
          dropped = true;
        });
      }
      if (dropped) {
        setTimeout(() => {
          if (checkMatches()) dropTiles();
        }, 700);
      }
    }

    function dropTiles() {
      setTimeout(drop, 500);
    }

    spinBtn.addEventListener('click', () => {
      if (isSpinning) return;
      isSpinning = true;
      spinBtn.disabled = true;
      createBoard(); // Yeni spin = yeni tahta
      setTimeout(() => {
        isSpinning = false;
        spinBtn.disabled = false;
      }, 1000);
    });

    // İlk spin
    createBoard();
  </script>
</body>
</html>