<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HAB Adventure - Hot Air Balloon</title>
    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; 
            background: linear-gradient(to bottom, #87CEEB, #4A90E2, #2C5AA0); 
            font-family: Arial, sans-serif; 
        }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 28px; font-weight: bold; text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7); z-index: 100;
        }
        #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); color: white; padding: 40px; border-radius: 25px;
            text-align: center; display: none; z-index: 200; backdrop-filter: blur(10px);
        }
        button { 
            background: linear-gradient(45deg, #FF6B35, #F7931E); color: white; border: none; 
            padding: 18px 40px; font-size: 22px; border-radius: 15px; cursor: pointer; 
            margin: 15px; box-shadow: 0 8px 20px rgba(255,107,53,0.4);
            transition: all 0.3s;
        }
        button:hover { transform: scale(1.05); box-shadow: 0 12px 30px rgba(255,107,53,0.6); }
        button:active { transform: scale(0.98); }
        canvas { display: block; }
        #instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.9); font-size: 18px; text-align: center;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>üèÜ <span id="score">0</span></div>
            <div>üìè <span id="height">0</span>m</div>
        </div>
        <div id="instructions">üëÜ Dokun ve tut = Y√úKSEL | Bƒ±rak = AL√áAL</div>
        <div id="gameOver">
            <h1>üéà BALON PATLADI! üéà</h1>
            <p>En Y√ºksek Puan: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">üöÄ YENƒ∞DEN BA≈ûLA</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === OYUN DEƒûƒ∞≈ûKENLERƒ∞ ===
        let scene, camera, renderer, balloon, obstacles = [], clouds = [], particles = [];
        let gameSpeed = 0.3, score = 0, height = 0, bestScore = localStorage.getItem('habBest') || 0;
        let gameRunning = false, gameOver = false;
        let balloonHeight = 0, liftForce = 0, isLifting = false;
        let tunnelMode = false, tunnelHeight = 0;
        let touchActive = false;

        // === BA≈ûLAT ===
        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.008);

            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 8, 15);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // I≈üƒ±klar
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // G√∂ky√ºz√º shader
            const skyGeometry = new THREE.SphereGeometry(800, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec3 dir = normalize(vWorldPosition);
                        float t = 0.5 * (dir.y + 1.0);
                        vec3 skyColor1 = vec3(0.2, 0.4, 0.8);
                        vec3 skyColor2 = vec3(0.7, 0.9, 1.0);
                        vec3 color = mix(skyColor1, skyColor2, t);
                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            scene.add(new THREE.Mesh(skyGeometry, skyMaterial));

            createBalloon();
            createMountains();
            setupControls();
        }

        // === SICAK HAVA BALONU ===
        function createBalloon() {
            const balloonGroup = new THREE.Group();
            balloonGroup.castShadow = true;

            // Balon g√∂vdesi
            const balloonGeometry = new THREE.SphereGeometry(2.2, 20, 16);
            const balloonMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFF6B9D,
                transparent: true, opacity: 0.95
            });
            const balloonMesh = new THREE.Mesh(balloonGeometry, balloonMaterial);
            balloonMesh.castShadow = true;
            balloonGroup.add(balloonMesh);

            // Balon detaylarƒ±
            const bandGeometry = new THREE.TorusGeometry(2.1, 0.1, 8, 20);
            const bandMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const band = new THREE.Mesh(bandGeometry, bandMaterial);
            band.rotation.x = Math.PI / 2;
            balloonGroup.add(band);

            // Ate≈ü efekti (animasyonlu)
            const fireGeometry = new THREE.ConeGeometry(0.9, 2.2, 12);
            const fireMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF4500,
                transparent: true, opacity: 0.8
            });
            const fire = new THREE.Mesh(fireGeometry, fireMaterial);
            fire.position.y = -2.3;
            balloonGroup.add(fire);
            balloonGroup.userData.fire = fire;

            // Sepet
            const basketGeometry = new THREE.CylinderGeometry(0.8, 0.8, 1.2, 8);
            const basketMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513, 
                flatShading: true 
            });
            const basket = new THREE.Mesh(basketGeometry, basketMaterial);
            basket.position.y = -3.3;
            basket.castShadow = true;
            balloonGroup.add(basket);

            balloon = balloonGroup;
            scene.add(balloon);
        }

        // === DAƒûLAR VE MAƒûARALAR ===
        function createMountains() {
            // Uzak daƒülar
            for (let i = 0; i < 20; i++) {
                const mountain = new THREE.Mesh(
                    new THREE.ConeGeometry(15 + Math.random() * 10, 30 + Math.random() * 20, 8),
                    new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(0.1, 0.3 + Math.random() * 0.2, 0.4) 
                    })
                );
                mountain.position.set(
                    (Math.random() - 0.5) * 200,
                    -15,
                    -100 - i * 25
                );
                mountain.scale.y = 0.6 + Math.random() * 0.4;
                scene.add(mountain);
            }
        }

        // === TUNNEL/MAƒûARA OLU≈ûTUR ===
        function createTunnel() {
            tunnelMode = true;
            tunnelHeight = balloon.position.y;
            
            const tunnelGroup = new THREE.Group();
            
            // Tunnel duvarlarƒ±
            const wallGeometry = new THREE.CylinderGeometry(8, 10, 80, 12, 1, true);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A4A4A,
                transparent: true, opacity: 0.9
            });
            const tunnelWall = new THREE.Mesh(wallGeometry, wallMaterial);
            tunnelWall.rotation.x = Math.PI / 2;
            tunnelWall.position.y = tunnelHeight;
            tunnelWall.position.z = -60;
            tunnelGroup.add(tunnelWall);

            // Tunnel i√ßi ƒ±≈üƒ±k
            const tunnelLight = new THREE.PointLight(0x88CCFF, 1, 100);
            tunnelLight.position.set(0, tunnelHeight, -30);
            tunnelGroup.add(tunnelLight);

            obstacles.push(tunnelGroup);
            scene.add(tunnelGroup);
        }

        // === ENGELLER (Kaya/Dikmeler) ===
        function createObstacle() {
            const obstacle = new THREE.Group();
            obstacle.castShadow = true;
            
            const sizes = [1.5, 2.2, 1.8];
            const size = sizes[Math.floor(Math.random() * sizes.length)];
            
            const rockGeometry = new THREE.DodecahedronGeometry(size, 1);
            const rockMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.08, 0.6, 0.35 + Math.random() * 0.2)
            });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.y = tunnelMode ? tunnelHeight + (Math.random() - 0.5) * 6 : -5 + Math.random() * 8;
            
            obstacle.add(rock);
            obstacle.position.set((Math.random() - 0.5) * 8, rock.position.y, -60);
            obstacles.push(obstacle);
            scene.add(obstacle);
        }

        // === KONTROLLER ===
        function setupControls() {
            // Dokunmatik - SADECE Y√úKSEL/AL√áAL
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

            // Klavye test
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') isLifting = true;
            });
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') isLifting = false;
            });
        }

        function onTouchStart(e) {
            e.preventDefault();
            touchActive = true;
            isLifting = true;
        }

        function onTouchEnd(e) {
            e.preventDefault();
            touchActive = false;
            isLifting = false;
        }

        // === OYUN BA≈ûLAT ===
        function startGame() {
            gameRunning = true;
            gameOver = false;
            score = 0;
            height = 0;
            gameSpeed = 0.3;
            balloonHeight = 0;
            tunnelMode = false;
            obstacles = [];
            clouds = [];
            createClouds();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            obstacles.forEach(obs => scene.remove(obs));
            clouds.forEach(c => scene.remove(c));
            startGame();
        }

        // === BULUTLAR ===
        function createClouds() {
            for (let i = 0; i < 15; i++) {
                const cloudGeometry = new THREE.SphereGeometry(3 + Math.random() * 2, 8, 6);
                const cloudMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.7
                });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(
                    (Math.random() - 0.5) * 100,
                    15 + Math.random() * 20,
                    -100 - Math.random() * 200
                );
                clouds.push(cloud);
                scene.add(cloud);
            }
        }

        // === ANA OYUN L√ñ√ñP ===
        function animate() {
            requestAnimationFrame(animate);

            if (!gameRunning) {
                // Balon ate≈ü animasyonu
                if (balloon && balloon.userData.fire) {
                    balloon.userData.fire.rotation.z += 0.2;
                    balloon.userData.fire.scale.setScalar(0.8 + Math.sin(Date.now() * 0.01) * 0.2);
                }
                renderer.render(scene, camera);
                return;
            }

            updateGame();
            checkCollisions();
            updateCamera();

            renderer.render(scene, camera);
        }

        function updateGame() {
            // R√ºzgar = otomatik ileri hareket (SUBWAY SURFERS)
            height += gameSpeed;
            score = Math.floor(height / 5);
            gameSpeed += 0.00015;

            // Lift mekaniƒüi
            liftForce = isLifting ? 0.35 : 0;
            balloonHeight += liftForce - 0.12; // S√ºrt√ºnme
            balloonHeight = Math.max(-8, Math.min(25, balloonHeight));
            balloon.position.y = 2 + balloonHeight;

            // Balon hafif sallanma
            balloon.rotation.z = Math.sin(Date.now() * 0.003 + balloonHeight * 0.1) * 0.1;
            balloon.position.x = Math.sin(height * 0.02) * 0.5;

            // UI
            document.getElementById('score').textContent = score;
            document.getElementById('height').textContent = Math.floor(height);

            // Tunnel spawn (her 500m'de bir)
            if (Math.floor(height) % 500 < 5 && height > 100 && !tunnelMode) {
                createTunnel();
            }

            // Engeller
            if (Math.random() < 0.025 + gameSpeed * 0.008) {
                createObstacle();
            }

            // Objeleri hareket ettir
            obstacles.forEach((obs, i) => {
                obs.position.z += gameSpeed * 3;
                obs.rotation.y += 0.01;
                if (obs.position.z > 25) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    if (tunnelMode) tunnelMode = false;
                }
            });

            // Bulutlar
            clouds.forEach(cloud => {
                cloud.position.z += gameSpeed * 0.8;
                if (cloud.position.z > 30) {
                    cloud.position.z = -200;
                    cloud.position.x = (Math.random() - 0.5) * 100;
                }
            });
        }

        function checkCollisions() {
            const balloonBox = new THREE.Box3().setFromObject(balloon);
            
            for (let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if (balloonBox.intersectsBox(obsBox)) {
                    endGame();
                    return;
                }
            }
        }

        function endGame() {
            gameRunning = false;
            gameOver = true;
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('habBest', bestScore);
            }
            document.getElementById('finalScore').textContent = bestScore;
            document.getElementById('gameOver').style.display = 'block';
        }

        function updateCamera() {
            camera.position.x = THREE.MathUtils.lerp(camera.position.x, balloon.position.x * 0.4, 0.08);
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, balloon.position.y + 6, 0.1);
            camera.position.z = balloon.position.z + 18;
            camera.lookAt(balloon.position);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ƒ∞lk dokunu≈üla ba≈üla
        renderer.domElement.addEventListener('touchstart', () => {
            document.getElementById('instructions').style.display = 'none';
            if (!gameRunning) startGame();
        }, { once: true });
    </script>
</body>
</html>