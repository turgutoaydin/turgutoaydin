<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Voxel Village – Sandbox Map</title>

<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #0b1e14;
    touch-action: none;
  }
  canvas { display: block; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* =========================
   ZOOM KAPAT
========================= */
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());

/* =========================
   SCENE
========================= */
const canvas = document.getElementById("c");
const scene = new THREE.Scene();

scene.background = new THREE.Color(0x0b1e14);

/* =========================
   CAMERA (ÜSTTEN ISOMETRIC)
========================= */
const camera = new THREE.PerspectiveCamera(
  45,
  innerWidth / innerHeight,
  0.1,
  200
);

camera.position.set(15, 20, 15);
camera.lookAt(0, 0, 0);

/* =========================
   RENDERER
========================= */
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true
});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

/* =========================
   LIGHT
========================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.7));

const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(20, 30, 10);
scene.add(sun);

/* =========================
   VOXEL MATERIALS
========================= */
const MAT_GRASS = new THREE.MeshStandardMaterial({ color: 0x2ecc71 });
const MAT_DIRT  = new THREE.MeshStandardMaterial({ color: 0x8e5a2a });
const MAT_WATER = new THREE.MeshStandardMaterial({ color: 0x3498db });
const MAT_FLOWER = new THREE.MeshStandardMaterial({ color: 0xe84393 });

/* =========================
   VOXEL MAP (X,Y)
========================= */
/*
0 = çimen
1 = toprak
2 = su
3 = çiçek
*/

const MAP = [
  [0,0,0,0,0,0,0,0],
  [0,0,3,0,0,3,0,0],
  [0,0,0,1,1,0,0,0],
  [0,3,0,1,1,0,3,0],
  [0,0,0,0,0,0,0,0],
  [0,0,2,2,2,2,0,0],
  [0,0,2,2,2,2,0,0],
  [0,0,0,0,0,0,0,0]
];

/* =========================
   VOXEL BUILD
========================= */
const tileSize = 1;
const mapGroup = new THREE.Group();

MAP.forEach((row, x) => {
  row.forEach((cell, z) => {

    let mat = MAT_GRASS;
    let height = 0.5;

    if (cell === 1) mat = MAT_DIRT;
    if (cell === 2) mat = MAT_WATER;
    if (cell === 3) mat = MAT_GRASS;

    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(tileSize, height, tileSize),
      mat
    );

    cube.position.set(
      x * tileSize,
      height / 2,
      z * tileSize
    );

    cube.userData = { x, z, type: cell };

    mapGroup.add(cube);

    /* FLOWER */
    if (cell === 3) {
      const flower = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.5, 0.2),
        MAT_FLOWER
      );
      flower.position.set(
        x * tileSize,
        height + 0.25,
        z * tileSize
      );
      mapGroup.add(flower);
    }
  });
});

mapGroup.position.x = -MAP.length / 2;
mapGroup.position.z = -MAP[0].length / 2;

scene.add(mapGroup);

/* =========================
   TOUCH CONTROL
========================= */
let lastX = 0;
let rotating = false;

let pinchStart = 0;
let camStartY = camera.position.y;

canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    rotating = true;
    lastX = e.touches[0].clientX;
  }

  if (e.touches.length === 2) {
    pinchStart = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    camStartY = camera.position.y;
  }
});

canvas.addEventListener("touchmove", e => {
  if (e.touches.length === 1 && rotating) {
    const dx = e.touches[0].clientX - lastX;
    mapGroup.rotation.y += dx * 0.004;
    lastX = e.touches[0].clientX;
  }

  if (e.touches.length === 2) {
    const dist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const zoom = (pinchStart - dist) * 0.01;
    camera.position.y = THREE.MathUtils.clamp(
      camStartY + zoom,
      8,
      30
    );
  }
});

canvas.addEventListener("touchend", () => rotating = false);

/* =========================
   ANIMATE
========================= */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

/* =========================
   RESIZE
========================= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>